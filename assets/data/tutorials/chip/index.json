{"hash":"c32ecfdb33b075b0057598b5b9118f3554a398cf","data":{"article":{"id":"a261411467f31e01488fc19c93220286","title":"Analysis of ChIP-seq data","tease":"","image":"","images":{},"category":null,"contact":"","date":null,"content":"<blockquote class=\"blockquote\">\n<small>\n<p>This tutorial was inspired by efforts of <a href=\"/people/mo-heydarian/\">Mo Heydarian</a> and <a href=\"https://github.com/malloryfreeberg\" target=\"_blank\" rel=\"noopener noreferrer\">Mallory Freeberg</a>. Tools higlighted here have been wrapped by <a href=\"https://github.com/bgruening\" target=\"_blank\" rel=\"noopener noreferrer\">Björn Grüning</a>, <a href=\"https://github.com/mvdbeek\" target=\"_blank\" rel=\"noopener noreferrer\">Marius van den Beek</a> and other <a href=\"/iuc/\">IUC</a> members. <a href=\"https://github.com/davebx\" target=\"_blank\" rel=\"noopener noreferrer\">Dave Bouvier</a> and <a href=\"https://github.com/martenson\" target=\"_blank\" rel=\"noopener noreferrer\">Martin Cech</a> helped fine tuning and deploying tools to Galaxy's public server. </p>\n</small>\n</blockquote>\n<p>In this tutorial we will:</p>\n<ul>\n<li>pre-process sequencing reads</li>\n<li>map reads</li>\n<li>post-process mapped data</li>\n<li>assess quality and strength of ChIP-signal</li>\n<li>display coverage plots in a genome browser</li>\n<li>call ChIP peaks with <code>MACS2</code></li>\n<li>inspect obtained calls</li>\n<li>look for sequence motifs within called peaks</li>\n<li>look at distribution of enriched regions across genes.</li>\n</ul>\n<h1 id=\"data\"><a href=\"#data\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data</h1>\n<p>Datasets for this tutorial were provided by <a href=\"http://mahonylab.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Shaun Mahony</a> and were generated in the lab of <a href=\"http://bmb.psu.edu/directory/bfp2\" target=\"_blank\" rel=\"noopener noreferrer\">Frank Pugh</a>.</p>\n<h2 id=\"reb1-chip-exo\"><a href=\"#reb1-chip-exo\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Reb1 ChIP-exo</h2>\n<p>For this analysis we will be using <a href=\"http://www.sciencedirect.com/science/article/pii/S0092867411013511\" target=\"_blank\" rel=\"noopener noreferrer\">ChIP-exo</a> datasets. For this experiment immunoprecipitation was performed with antobodies against Reb1. Reb1 recognizes a specific sequence (<code>TTACCCG</code>) and is involved in many aspects of transcriptional regulation by all three yeast RNA polymerases and promotes formation of nucleosome-free regions (NFRs) (<a href=\"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2677553/\" target=\"_blank\" rel=\"noopener noreferrer\">Hartley &#x26; Madhani:2009</a>;  <a href=\"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2039754/\" target=\"_blank\" rel=\"noopener noreferrer\">Raisner:2005</a>).</p>\n<div class=\"alert alert-info\" role=\"alert\">\nAlthough this is ChIP-exo data, in this tutorial we will analyze it as if it were standard ChIP-seq. We will explain peculiarities of ChIP-exo analysis in a dedicated tutorial.\n</div>\n<h2 id=\"data-description\"><a href=\"#data-description\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data description</h2>\n<p>There are four datasets:</p>\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Reb1_R1</td>\n<td>ChIP experiment, Replicate 1</td>\n</tr>\n<tr>\n<td>Input_R1</td>\n<td>Input DNA, Replicate 1</td>\n</tr>\n<tr>\n<td>Reb1_R2</td>\n<td>ChIP experiment, Replicate 2</td>\n</tr>\n<tr>\n<td>Input_R2</td>\n<td>Input DNA, Replicate 2</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"data-location\"><a href=\"#data-location\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data location</h2>\n<!-- Modal for Library import video -->\n<div class=\"modal fade\" id=\"lib_video\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"libVid\">\n  \t<div class=\"modal-dialog\" role=\"document\">\n    \t<div class=\"modal-content\">\n      \t\t<div class=\"modal-header\">\n        \t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\n        \t\t<h4 class=\"modal-title\" id=\"myModalLabel\">Importing from History</h4>\n      \t\t</div>\n      \t\t<div class=\"modal-body\">\n      \t\t\t<div class=\"embed-responsive embed-responsive-16by9\">\n  \t\t\t\t\t<iframe class=\"embed-responsive-item\" src=\"https://player.vimeo.com/video/212753639\"></iframe>\n\t\t\t\t</div>\n\t\t\t</div>\t\n    \t</div>\n  \t</div>\n</div>\n<p>These datasets are deposited in a <a href=\"https://usegalaxy.org/libraries/folders/F050cbba300e2dbed\" target=\"_blank\" rel=\"noopener noreferrer\">Galaxy library</a> (watch <a href=\"#\" data-toggle=\"modal\" data-target=\"#lib_video\">Video</a> on how to import data from a library):</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/lib.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Galaxy data library containing the reads</strong>. Here you can see two replicates (<code>R1</code> and <code>R2</code>). This is single-end data. Upload datasets into a new history by selecting all datasets and clicking <code>to History</code> button. Name the new history and click <code>Import</code> (watch <a href=\"#\" data-toggle=\"modal\" data-target=\"#lib_video\">this video</a>).</small></td>\n</tr>\n</tbody>\n</table>\n<!-- Modal for Creating collection video -->\n<div class=\"modal fade\" id=\"collection_create_video\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"collection_create_Vid\">\n  \t<div class=\"modal-dialog\" role=\"document\">\n    \t<div class=\"modal-content\">\n      \t\t<div class=\"modal-header\">\n        \t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\n        \t\t<h4 class=\"modal-title\" id=\"myModalLabel\">Creating a dataset collection | Single end data</h4>\n      \t\t</div>\n      \t\t<div class=\"modal-body\">\n      \t\t\t<div class=\"embed-responsive embed-responsive-16by9\">\n  \t\t\t\t\t<iframe class=\"embed-responsive-item\" src=\"https://player.vimeo.com/video/212757252\"></iframe>\n\t\t\t\t</div>\n\t\t\t</div>\t\n    \t</div>\n  \t</div>\n</div>\n<h2 id=\"uploading\"><a href=\"#uploading\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Uploading</h2>\n<p>After uploading datasets into Galaxy history we will combine all datasets into a single dataset collection. This will simplify downstream processing of the data. The process for creating a collection for this tutorial is <a href=\"#\" data-toggle=\"modal\" data-target=\"#collection_create_video\">is shown here</a>.</p>\n<h1 id=\"mapping-and-post-processing\"><a href=\"#mapping-and-post-processing\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Mapping and Post-processing</h1>\n<h2 id=\"mapping\"><a href=\"#mapping\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Mapping</h2>\n<p>In this particular case the data is of very high quality and do not need to be trimmed or postprocessed in any way before mapping. We will proceed by mapping all the data against the latest version of the yeast genome <code>sacCer3</code>:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/mapping.png\"></td>\n</tr>\n</tbody>\n</table>\n<p>|<small><strong>Mapping all data at once</strong>. Note that <strong>Select input type</strong> is set to <code>Single fastq</code> and by selecting folder (<i class=\"far fa-folder\" aria-hidden=\"true\"></i>) button you can select as entire collection of fastq datasets. <strong>Important</strong>: here we also set readgroups automatically by toggling <strong>Set readgroups information</strong> dropdown to <code>Set readgroups (SAM/BAM specification)</code> and setting all <strong>Auto-assign</strong> button to <code>Yes</code>. </small></p>\n<div class=\"alert alert-warning\" role=\"alert\"><i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i>Running <code>BWA</code> on a collection will generate another collection of BAM files. Name this collection <code>mapped data</code> (for help on how to rename a collection <a href=\"#\" data-toggle=\"modal\" data-target=\"#collection_rename_video\">see this video</a>).</div>\n<!-- Modal for Renaming collection video -->\n<div class=\"modal fade\" id=\"collection_rename_video\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"collection_rename_Vid\">\n  \t<div class=\"modal-dialog\" role=\"document\">\n    \t<div class=\"modal-content\">\n      \t\t<div class=\"modal-header\">\n        \t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\n        \t\t<h4 class=\"modal-title\" id=\"myModalLabel\">Renaming a collection</h4>\n      \t\t</div>\n      \t\t<div class=\"modal-body\">\n      \t\t\t<div class=\"embed-responsive embed-responsive-16by9\">\n  \t\t\t\t\t<iframe class=\"embed-responsive-item\" src=\"https://player.vimeo.com/video/212758694\"></iframe>\n\t\t\t\t</div>\n\t\t\t</div>\t\n    \t</div>\n  \t</div>\n</div>\n<h2 id=\"post-processing\"><a href=\"#post-processing\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Post-processing</h2>\n<p>For post-processing we will remove all non-uniquely mapped reads. This can be done by simply filtering out all reads with <a href=\"http://genome.sph.umich.edu/wiki/Mapping_Quality_Scores\" target=\"_blank\" rel=\"noopener noreferrer\">mapping quality</a> less than <code>20</code> using <strong>NGS: SAMtools → Filter SAM or BAM</strong>:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/bam_filter.png\"></td>\n</tr>\n</tbody>\n</table>\n<p>|<small><strong>Filtering multi-mapped reads</strong> by restricting the data to reads with mapping quality above 20. Note that by selecting folder (<i class=\"far fa-folder\" aria-hidden=\"true\"></i>) button you can select as entire collection of BAM datasets to filter at once.</small></p>\n<div class=\"alert alert-warning\" role=\"alert\"><i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i> Running <code>Filter SAM or BAM</code> on a collection will generate another collection of BAM files. Name this collection <code>filtered data</code> (for help on how to rename a collection <a href=\"#\" data-toggle=\"modal\" data-target=\"#collection_rename_video\">see this video</a>).</div>\n<h1 id=\"assessment-of-chip-quality\"><a href=\"#assessment-of-chip-quality\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Assessment of ChIP quality</h1>\n<p>After we mapped and filtered the reads it is time to make some inferences about how good the underlying data is. </p>\n<h2 id=\"correlation-among-samples\"><a href=\"#correlation-among-samples\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Correlation among samples</h2>\n<p>In out experiment there are two replicates, each containing treatment and input (control) datasets. The first thing we can check is if the samples are correlated (in other words if treatment and control samples across the two replicates contain this same kind of signal). To do this we first generate read count matrix using <strong>NGS: DeepTools → multiBamSummary</strong>. </p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/multibamsummary.png\"></td>\n</tr>\n</tbody>\n</table>\n<p>|<small><strong>Running multiBAMsummary</strong> on a collection of BAM datasets (as before you can select collection by pressing folder (<i class=\"far fa-folder\" aria-hidden=\"true\"></i>) button).</small></p>\n<p>This tool breaks genome into bins of fixed size (10,000 bp in our example) and computes the number of reads falling within each bin. Here is a fragment of its output:</p>\n<pre><code>#'chr' 'start' 'end'  'Reb1_R1'  'Input_R1'  'Input_R1'  'Reb1_R2'\nchrVI      0    1000   19.0         41.0         3.0        6.0\nchrVI   1000    2000   29.0         30.0        13.0        5.0\nchrVI   2000    3000    0.0          0.0         0.0        0.0\nchrVI   3000    4000    0.0          2.0         0.0        0.0\nchrVI   4000    5000 7447.0        139.0         7.0     2645.0\n</code></pre>\n<p>we can then feed this matrix into <strong>NGS: DeepTools → plotCorrelation</strong> to generate heat map like this:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/plotcorr.png\"></td>\n</tr>\n<tr>\n<td><small><strong>A.</strong> Running <code>plotCorrelation</code> on output of <code>multiBamSummary</code>.</small></td>\n</tr>\n<tr>\n<td><img src=\"/src/tutorials/chip/corr.png\"></td>\n</tr>\n<tr>\n<td><small><strong>B.</strong> Heatmap of four samples: Treatments (Rab1) and controls (Input) are well correlated among themselves.</small></td>\n</tr>\n</tbody>\n</table>\n<p>Here we can see that there are good correlations between replicates (between Reb1_R1 and Reb1_R2, and between input_R1 and input_R2), while correlations between treatments (Reb1) and controls (input) are weak. This is a good sign implying that there is some signal on our data.</p>\n<h2 id=\"assessing-signal-strength\"><a href=\"#assessing-signal-strength\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Assessing signal strength</h2>\n<p>How do we tell is we do have signal coming from ChIP enrichment? One way of doing this is Signal Extraction Scaling (SES) proposed by <a href=\"https://www.degruyter.com/downloadpdf/j/sagmb.2012.11.issue-3/1544-6115.1750/1544-6115.1750.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Diaz:2012</a>. SES works as follows. Suppose we have two datasets: ChIP and Input DNA. We divide genome into <em>N</em> non-overlapping windows (<em>N</em> = 10 in the example below) and for each window compute the number of reads. This way we end up with two lists: one listing read counts for ChIP (ChIP list) and the other for Input (Input list):</p>\n<pre><code>Window   ChIP-count Input-count\n-------------------------------\n 1         3          3\n 2         4          3\n 3         2          1\n 4         1          3\n 5         3          3\n 6        27          2\n 7        18          3\n 8         2          2\n 9        45          3\n10         8          3\n</code></pre>\n<p> We then sort the ChIP list in ascending order and move elements from Input-list to match this order:</p>\n<pre><code> Window   ChIP-count Input-count\n-------------------------------\n4           1         3\n3           2         1\n8           2         2\n1           3         3\n5           3         3\n2           4         3\n10          8         3\n7          18         3\n6          27         2\n9          45         3\n</code></pre>\n<p>Now let's add another two columns to this dataset. These columns will show percentage of reads summing up to each row for ChIP and Input data. For example, 0.044 on row 3 is (1 + 2 + 2)/113 = 0.044. </p>\n<pre><code> 1   2   3  4      5\n-------------------------------\n 4   1   3  0.008  0.115\n 3   2   1  0.026  0.153\n 8   2   2  0.044  0.230\n 1   3   3  0.070  0.346\n 5   3   3  0.097  0.230\n 2   4   3  0.132  0.576\n10   8   3  0.203  0.692\n 7  18   3  0.362  0.807\n 6  27   2  0.601  0.884\n 9  45   3  1.000  1.000\n------------------------\n   113  26    \n\nWhere:\n\n1 = Window, 2 = read count in ChIP, 3 = read count in Input\n4 = % or read to this point in ChIP 5 = % of read to this point \n</code></pre>\n<p>In the matrix above a large portion of ChIP reads (column 4) is concentrated in the few bins close to the bottom. This is not the case for the input reads (column 5). If we plot two last columns of this matrix we will get a curve like this:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/ses.png\"></td>\n</tr>\n<tr>\n<td><small><strong>SES</strong> plot for our toy example. Most \"reads\" in the ChIP experiment are concentrated in the last three bins.</small></td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://deeptools.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">DeepTools</a> provide a nice explanation of how the success of a ChIP experiment can be judged based on SES (also called <em>fingerprint</em>) plots:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/fingerprint_dt.png\"></td>\n</tr>\n<tr>\n<td><small><strong>DeepTools</strong> explanation of SES plots.</small></td>\n</tr>\n</tbody>\n</table>\n<p>So let's apply this to our own data using <strong>NGS: DeepTools → plotFingerprint</strong>:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/plotfingerprint.png\"></td>\n</tr>\n<tr>\n<td><small><strong>A.</strong> Running <code>plotFingerprint</code> on filtered data (15.).</small></td>\n</tr>\n<tr>\n<td><img src=\"/src/tutorials/chip/plotfingerprint_out.png\"></td>\n</tr>\n<tr>\n<td><small><strong>B.</strong> SES fingerprint of four samples: Treatments (Rab1) show characteristic shape indicating of ChIP-signal. Approximately 30% of reads are contained in several % of genome.</small></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"generating-bigwig-datasets-for-display\"><a href=\"#generating-bigwig-datasets-for-display\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Generating bigWig datasets for display</h1>\n<p>In this section we will convert BAM files generated with <code>bwa</code> into <a href=\"https://genome.ucsc.edu/goldenpath/help/bigWig.html\" target=\"_blank\" rel=\"noopener noreferrer\">bigWig</a> format that will allow us to view read coverage distribution across the genome. We will also \"pre-warm\" a genome browser for displaying peaks we will be calling in the next section.</p>\n<h2 id=\"generating-bigwig-datasets\"><a href=\"#generating-bigwig-datasets\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Generating bigWig datasets</h2>\n<p>We will use <strong>NGS: DeepTools → bamCoverage</strong>:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/bam_cov_1.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Running bamCoverage</strong> on a collection of filtered BAM datasets (as before you can select collection by pressing folder (<i class=\"far fa-folder\" aria-hidden=\"true\"></i>) button). Here we set <strong>Bin size</strong> to <code>25</code>.  Next we set <strong>Effective genome size</strong> to <code>user specified</code> and enter <code>12000000</code> (approximate size of <em>Saccharomyces cerevisiae</em> genome). Because this tool has a particularly long interface we cut out important sections to make this image (see the panes below). </small></td>\n</tr>\n<tr>\n<td><img src=\"/src/tutorials/chip/bam_cov_3.png\"></td>\n</tr>\n<tr>\n<td><small>Finally we set <strong>Extend reads to the given average fragment size</strong> to <code>150</code>. This is because in this particular experiment DNA was size selected to be between 120 and 170 bp for library preparation.</small></td>\n</tr>\n</tbody>\n</table>\n<div class=\"alert alert-warning\" role=\"alert\"><i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i> Running <code>bamCoverage</code> on a collection of BAM datasets will generate a collection of bigWig datasets. Name this collection <code>coverage</code> (for help on how to rename a collection <a href=\"#\" data-toggle=\"modal\" data-target=\"#collection_rename_video\">see this video</a>).</div>\n<h2 id=\"displaying-coverage-tracks-in-a-browser\"><a href=\"#displaying-coverage-tracks-in-a-browser\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Displaying coverage tracks in a browser</h2>\n<!-- Modal for displaying in IGV -->\n<div class=\"modal fade\" id=\"igv_video\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"igv_Vid\">\n  \t<div class=\"modal-dialog\" role=\"document\">\n    \t<div class=\"modal-content\">\n      \t\t<div class=\"modal-header\">\n        \t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\n        \t\t<h4 class=\"modal-title\" id=\"myModalLabel\">Displaying multiple datasets in IGV</h4>\n      \t\t</div>\n      \t\t<div class=\"modal-body\">\n      \t\t\t<div class=\"embed-responsive embed-responsive-16by9\">\n  \t\t\t\t\t<iframe class=\"embed-responsive-item\" src=\"https://player.vimeo.com/video/123414437\"></iframe>\n\t\t\t\t</div>\n\t\t\t</div>\t\n    \t</div>\n  \t</div>\n</div>\n<p>Now we can display bigWig datasets generated in the previous section in a genome browser. There is a variety of available browsers. In this tutorial we will use IGV Browser (this <a href=\"#\" data-toggle=\"modal\" data-target=\"#igv_video\">video</a> shows how to display multiple datasets in IGV). </p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/cvrg_collection.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Collection of bigWigs</strong> produced by <code>bamCoverage</code> above. Note that in the one expanded dataset (<code>Reb</code>_R2<code>) there is a</code>display at IGV` link.</small></td>\n</tr>\n</tbody>\n</table>\n<p>Clicking this link in all four datasets (you will need to expand each dataset by clicking on it. This will expose IGV link) and focusing browser on <em>MPH1</em> (<em>YIR002C</em>) gene will produce the following image:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/igv1.png\"></td>\n</tr>\n</tbody>\n</table>\n<p>|<small><strong>Coverage</strong> distributing within IGV. Here ChIP replicates are colored in orange and controls are blue. All four tracks were set to maximum value of <code>70</code>.</small></p>\n<h1 id=\"calling-peaks\"><a href=\"#calling-peaks\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Calling peaks</h1>\n<p>While the peaks shown in the browser screenshot above are pretty clear and consistent across the two replicates, looking at the entire genome in the browser is hardly a sustainable way to identify all peaks. There are several ways for identifying binding events genome-wide. They are summarized in the figure below:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/t15_peak_calling.jpg\"></td>\n</tr>\n</tbody>\n</table>\n<p>|<small><strong>Outline of three ChIP-seq binding event detection methods</strong>. Peak-finding methods typically either shift the ChIP-seq tag locations in a 3′ direction by half the expected fragment length, or extend the length of the tag in a 3′ direction to be equal to the expected fragment length. Tags from opposite strands are merged to construct an unstranded tag density landscapes, and binding event locations are predicted from the locations with maximum tag coverage within each region that contains a significant enrichment of ChIP-seq tags (i.e. the peak summit). Peak-pairing methods [e.g. GeneTrack build similar tag density landscapes, but retain strandedness information and typically do not shift or extend the tag locations. Peak locations are determined on each strand separately, and nearby peaks in the correct stranded orientation within a given distance are paired together. Binding event locations are predicted from the peak-pair midpoint locations. Probabilistic binding detection methods aim to estimate the locations of binding events that could have given rise to the observed ChIP-seq tag locations. These methods begin training with initial guesses of binding event locations and a model of how tags are expected to be distributed around real ChIP-seq binding events. During each training step, every ChIP-seq tag is probabilistically associated with nearby binding events, depending on the distance between the tag and the event location. Given these probabilistic tag assignments, binding event locations are updated to achieve a better fit with their associated tags, and the model of how tags are distributed around binding events is updated to reflect the accumulation of tags around all current binding events. During the training process, binding events with few assigned tags are weeded out of the model, and the process eventually converges to a set of final binding locations. (Figure and legend from <a href=\"http://www.tandfonline.com/doi/full/10.3109/10409238.2015.1051505\" target=\"_blank\" rel=\"noopener noreferrer\">Mahony and Pugh:2015</a>).</small></p>\n<p>In this tutorials we will use <a href=\"https://github.com/taoliu/MACS\" target=\"_blank\" rel=\"noopener noreferrer\">MACS2</a> peak caller.</p>\n<h2 id=\"how-does-macs-work\"><a href=\"#how-does-macs-work\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>How does MACS work?</h2>\n<p><a href=\"https://www.ncbi.nlm.nih.gov/pubmed?cmd=search&#x26;term=18798982\" target=\"_blank\" rel=\"noopener noreferrer\">MACS</a> (or its current version <code>MACS2</code>) performs several steps for calling peaks from paired treatment/control datasets:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/t15_macs_workflow.jpg\"></td>\n</tr>\n<tr>\n<td><small><strong>Steps of the MACS workflow</strong> (From <a href=\"http://www.nature.com/nprot/journal/v7/n9/full/nprot.2012.101.html\" target=\"_blank\" rel=\"noopener noreferrer\">Feng:2012</a>).</small></td>\n</tr>\n</tbody>\n</table>\n<p>Here is a concise description of these steps:</p>\n<ul>\n<li><strong>Removing redundancy</strong> - MACS retains uniquely mapped reads and removes reads that are repeatedly mapped to the same location. This reduces effects of PCR amplification biases during library preparation.</li>\n<li><strong>Build model and estimate fragment size</strong> - one of the MACS inputs is the fragment size or <em>bandwidth</em>, which is approximate size of DNA fragments generated during fragmentation step of library preparation. MACS first slides a window sized at twice the bandwidth across the genome and finds instances where read counts enriched by between 10 and 30 fold relative to the genome background. It then randomly samples 1,000 of such regions and build the model. To build the model it separates reads mapping to each of the strands and build two distributions (two modes). The midpoint between the two modes is the middle of the binding size and the distance between the modes is the fragment size <code>d</code> (see Figure below).</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/t15_macs_model.png\"></td>\n</tr>\n<tr>\n<td><small>Peaks mapped to two strands are treated separately to build two coverage density profiles - two two modes. The distance between the modes is the fragment size <code>d</code>. This profile is build from 1,000 randomply selected enriched regions (From <a href=\"https://www.ncbi.nlm.nih.gov/pubmed?cmd=search&#x26;term=18798982\" target=\"_blank\" rel=\"noopener noreferrer\">Zhang:2008</a>).</small></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>Generate peaks</strong> - now that <em>d</em> has been defined MACS slides a window of size <em>2d</em> across the genome to identify regions significantly enriched in the ChIP sample. MACS assumes that background reads obey <a href=\"https://en.wikipedia.org/wiki/Poisson_distribution\" target=\"_blank\" rel=\"noopener noreferrer\">Poisson distribution</a>. Thus given the number of reads in a given interval within the control sample we can calculate the probability of having observed number of reads in the ChIP sample (e.g., see flood example <a href=\"https://en.wikipedia.org/wiki/Poisson_distribution#Examples_of_probability_for_Poisson_distributions\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>). This procedure is performed for several intervals around the examined location (<em>2d</em>, 1kb, 5kb, 10kb, and the whole genome) and the maximum value is chosen. One problem with this approach is that it only works if both samples (ChIP and control) are sequenced to the depth, which is not usually happening in practice. To correct with this MACS scales down the larger sample. </li>\n<li><strong>Compute False Discovery Rate (FDR)</strong> - <a href=\"http://www.nature.com/nprot/journal/v7/n9/full/nprot.2012.101.html\" target=\"_blank\" rel=\"noopener noreferrer\">Feng:2012</a> explains computing FDR in MACS as follows: <em>\"When a control sample is available </em>(and you should really always use it - AN)<em>, MACS can also estimate an empirical FDR for every peak by exchanging the ChIP-seq and control samples and identifying peaks in the control sample using the same set of parameters used for the ChIP-seq sample. Because the control sample should not exhibit read enrichment, any such peaks found by MACS can be regarded as false positives. For a particular P value threshold, the empirical FDR is then calculated as the number of control peaks passing the threshold divided by the number of ChIP-seq peaks passing the same threshold.\" </em></li>\n</ul>\n<h2 id=\"finding-peaks\"><a href=\"#finding-peaks\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Finding peaks</h2>\n<p>In our case we have two replicates each containing ChIP and input DNA samples. We will first run <code>MACS2</code> on pooled data (combining two ChIP samples and two inputs, respectively). We will then run <code>MACS2</code> on each replicate individually. Finally, we will pick a robust set of peaks present in all three callsets.</p>\n<h3 id=\"splitting-data-into-individual-samples\"><a href=\"#splitting-data-into-individual-samples\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Splitting data into individual samples</h3>\n<p>One complication with the way we processed all data is that we have combined everything in a single dataset collection. MACS however will need for us to separate ChIP samples and controls. Fortunately for us <a href=\"/tutorials/chip/#mapping\">we have set readgroups</a> when we were mapping reads to the yeast genome. This will come handy for us right now because we will:</p>\n<ul>\n<li>merge the entire collection of mapped and filtered BAMs into a singe BAM dataset</li>\n<li>split this dataset into four separate BAM files using readgroups</li>\n<li>run MACS on resulting files.</li>\n</ul>\n<div class=\"alert alert-danger\" role=\"alert\">This slight complication is a result of current implementation of collection in Galaxy. As we are advancing collection implementation, this tutorial will be modified to make this steps more elegant in the future.</div>\n<p>First, to merge a collection of mapped, filtered BAM files into a single dataset we will use <strong>NGS: Picard → MergeSamFiles</strong>:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/merge_bam.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Merging a collection</strong> with <code>MergeSamFiles</code>. Here we use default parameters.</small></td>\n</tr>\n</tbody>\n</table>\n<p>Next, we will use <strong>NGS: SAMtools → Split</strong> to separate merged file into individual BAM files. Each resulting BAM file will contained aligned reads corresponding to original four datasets:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/bam_split.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Splitting BAM dataset</strong> on readgroups. This will produce four BAM datasets.</small></td>\n</tr>\n<tr>\n<td><img src=\"/src/tutorials/chip/split_data.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Resulting datasets</strong>. Each contains aligned reads from the four original conditions.</small></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"running-macs2\"><a href=\"#running-macs2\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Running MACS2</h3>\n<p>Now it is time to run MACS2. First we will use <strong>NGS: Peak calling → MACS2 predictd</strong> tool from the <code>MACS2</code> package. This tool will help us to find optimal parameters for running peak calling function of <code>MACS2</code>:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/predictd1.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Running <code>predictd</code></strong> for estimate the <em>d</em> parameter. Here we set <strong>Effective genome size</strong> to Yeast-specific value, set <strong>Band width</strong> to <code>150</code> (the fragment length after size selection), and increase <strong>Set upper mfold bound</strong> to <code>100</code> (this is a ChIP-exo experiment where we expect to have sharp, greatly enriched regions. Leaving this parameter at its default of <code>50</code> may fail to find any peaks because these particular datasets were generated by ChIP-exo protocol).</small></td>\n</tr>\n</tbody>\n</table>\n<div class=\"alert alert-warning\" role=\"alert\"><i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i> Do this on the other replicate as well!</div>\n<p>This procedure will help us estimate the <em>d</em> parameter by performing the [cross-correlation] analysis between reads mapping to + and - strands. Let's look at these results:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Replicate 1</th>\n<th>Replicate 2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><img src=\"/src/tutorials/chip/d_r1.png\"></td>\n<td><img src=\"/src/tutorials/chip/d_r2.png\"></td>\n</tr>\n<tr>\n<td align=\"left\"><small>Peak model and lag between strands.</small></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>In the case of these data peaks are very sharp and have narrow gap between them: <code>27</code> and <code>33</code> bp for replicate 1 and 2, respectively. We will use an average of these values, <code>30</code>, as <code>--extsize</code> parameter for calling peaks using <strong>NGS: Peak calling → MACS2 callpeak</strong>:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/macs1.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Calling peaks with <code>MACS2</code> on pooled data</strong>. Here we choose multiple inputs by pressing <i class=\"far fa-copy\" aria-hidden=\"true\"></i> button and selecting both ChIP datasets in <strong>ChIP-Seq Treatment File</strong> and both Input DNA datasets in <strong>ChIP-Seq Control File</strong>. We then select <code>Saccharomyces cerevisiae</code> genome as the <strong>Effective genome size</strong>. <code>MACS2</code>s interface is long and we split it into several pieces in this figure. See the lower section as well - it is important!</small></td>\n</tr>\n<tr>\n<td><img src=\"/src/tutorials/chip/macs2.png\"></td>\n</tr>\n<tr>\n<td><small>In this lower part of <code>MACS2</code> interface set <strong>Build model</strong> to <code>Do not build the shifting model</code> (we have already done this with <code>preductd</code> in the previous step) and *<em>Set extension size</em> to <code>30</code> (the number we estimated in the previous step). Finally, we will only ask <code>MACS2</code> to produce two outputs: <code>Peak summits</code> and the one it produced by default, which contains peak coordinates.</small></td>\n</tr>\n</tbody>\n</table>\n<p>If you set parameters as was shown above <code>MACS2</code> will produce two outputs (if it produced more just find the ones called <code>narrow peaks</code> and <code>summits</code>). Let's click on the pencil icon(<i class=\"fas fa-pencil-alt\" aria-hidden=\"true\"></i>) adjacent to <code>summits</code> and <code>narrow peak</code> datasets and rename then as shown below:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/macs_out_renamed.png\"></td>\n</tr>\n<tr>\n<td><small><strong><code>MACS2</code> output</strong> with <code>summits</code> and <code>narrow peak</code> datasets renamed.</small></td>\n</tr>\n</tbody>\n</table>\n<p>Next, we will run <code>MACS2</code> on BAM datasets for Replicate 1 only:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/macs3.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Calling peaks with <code>MACS2</code> on R1</strong> With the exception of selecting only R1 datasets, all other parameters should be set as in the previous figure.</small></td>\n</tr>\n</tbody>\n</table>\n<div class=\"alert alert-warning trim-p\" role=\"alert\"><i class=\"fa fa-exclamation-circle\" aria-hidden=\"true\"></i> Now do this by yourself:\n<hr>\n<ul>\n<li>rename resulting datasets as <code>R1 summits</code> and <code>R1 peaks</code></li>\n<li>run <code>MACS2</code> run on Replicate 2</li>\n<li>rename resulting <code>summits</code> and <code>narrow peak</code> datasets as <code>R2 summits</code> and <code>R2 peaks</code>.</li>\n</ul>\n</div>\n<p>In the end you should have something like this:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/all_macs_datasets.png\"></td>\n</tr>\n</tbody>\n</table>\n<p>|<small><strong>All <code>MACS2</code> datasets</strong>. After running <code>MACS2</code> three times we should have polled, R1, and R2 datasets.</small></p>\n<h1 id=\"inspecting-peaks\"><a href=\"#inspecting-peaks\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Inspecting peaks</h1>\n<h2 id=\"what-is-in-the-output\"><a href=\"#what-is-in-the-output\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>What is in the output?</h2>\n<p>Looking at MACS2 data we have gotten the following numbers of peaks:</p>\n<table>\n<thead>\n<tr>\n<th>Pooled</th>\n<th>Replicate 1</th>\n<th>Replicate 2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>974</td>\n<td>955</td>\n<td>784</td>\n</tr>\n</tbody>\n</table>\n<p>Peaks data is generated in the following format:</p>\n<pre><code>   1      2      3            4   5 6        7        8        9  10\n--------------------------------------------------------------------\nchrI     35    491 MACS2_peak_1 176 . 10.35332 21.51081 17.68957 101\nchrI  87135  87212 MACS2_peak_2 127 .  7.71763 15.89278 12.78060  26\nchrI  92612  92793 MACS2_peak_3 153 .  9.22373 18.72748 15.31966  49\nchrI 119739 119782 MACS2_peak_4  78 .  6.08885 10.52482  7.82302  25\n</code></pre>\n<p>where columns  are:</p>\n<ol>\n<li>Chromosome</li>\n<li>Start</li>\n<li>End</li>\n<li>Iterative id given by <code>MACS2</code></li>\n<li>Integer score for display</li>\n<li>Strand (irrelevant in this case)</li>\n<li>Fold-change (fold enrichment for this peak summit against random Poisson distribution with local <a href=\"https://en.wikipedia.org/wiki/Poisson_distribution\" target=\"_blank\" rel=\"noopener noreferrer\">lambda</a>)</li>\n<li>-log<sub>10</sub><em>P</em>-value (e.g., 17.68 is 1 x 10<sup>-17</sup>)</li>\n<li>-log<sub>10</sub><em>Q</em>-value from <a href=\"https://en.wikipedia.org/wiki/False_discovery_rate#Benjamini.E2.80.93Hochberg.E2.80.93Yekutieli_procedure.\" target=\"_blank\" rel=\"noopener noreferrer\">Benjamini–Hochberg–Yekutieli procedure</a> </li>\n<li>Relative summit position to peak start</li>\n</ol>\n<h2 id=\"how-many-peaks-are-common-between-replicates\"><a href=\"#how-many-peaks-are-common-between-replicates\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>How many peaks are common between replicates?</h2>\n<p>To see how many peaks are common between the pooled datasets and the two replicates we will use <strong>Operate on Genomic Intervals → Join</strong> tool twice.</p>\n<div class=\"alert alert-danger trim-p\" role=\"alert\">\n<p>Galaxy main has two tools called <strong>Join</strong>. Don't confuse them! Here we are using the one from <strong>Operate on Genomic Intervals</strong> section.</p>\n</div>\n<p>First we will join <code>Peaks pooled</code> with <code>Peaks R1</code>:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/join1.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Joining Pooled and R1</strong> results with <code>Join</code> tool. Note that because we renamed the datasets they are now easily selectable.</small></td>\n</tr>\n</tbody>\n</table>\n<p>Next we will join the result of the previous operation with <code>Peaks R2</code>:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/join2.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Joining Pooled/R1 with R2</strong> results with <code>Join</code> tool. Note that because we renamed the datasets they are now easily selectable.</small></td>\n</tr>\n</tbody>\n</table>\n<p>This results in 723 regions are shared among polled, R1, and R2 peaks. Let's call this <strong>High confidence set</strong>. Before we can use it however, let's cut out only relevant columns. Since we have produced this dataset by joining three other datasets it is three times wider (30 columns). To cut this first three columns we can use <strong>Text Manipulation → Cut columns</strong> tool:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/cut.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Cutting columns</strong> from <code>Join</code> output.</small></td>\n</tr>\n</tbody>\n</table>\n<div class=\"alert alert-warning trim-p\">\n<p>Rename the last dataset as <code>High confidence set</code>. This will make it easy to find as we continue.</p>\n</div>\n<div class=\"alert alert-danger trim-p\" role=\"alert\">\n<p>Using <code>Cut columns</code> tool produces a dataset of tabular type. However, by cutting the first ten columns we have created a dataset in BED format. Thus we need to let Galaxy know about that by resetting metadata as shown below.</p>\n</div>\n<p>Next we need to make sure that output of <code>Cut columns</code> tool has the type <code>BED</code>. To do this we will edit its metadata as show below:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/bed_type.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Setting metadata</strong> to datatype <code>BED</code>. Click the pencil icon(<i class=\"fas fa-pencil-alt\" aria-hidden=\"true\"></i>) adjacent to the dataset and choose <strong>Datatype</strong> tab. There you will be able to set it to <code>BED</code>.</small></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"lets-look-at-everything-in-the-browser\"><a href=\"#lets-look-at-everything-in-the-browser\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Let's look at everything in the browser</h2>\n<p>Let's visualize Merged peaks as well as Narrow peaks and Summits produced by <code>MACS2</code> in IGV by clicking on <code>display with IGV local</code> links adjacent to <code>Peaks pooled</code> and <code>High confidence set</code> datasets (you should <a href=\"/tutorials/chip/#displaying-coverage-tracks-in-a-browser\">already have browser open</a>):</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/igv2.png\"></td>\n</tr>\n</tbody>\n</table>\n<p>|<small><strong>An overview in IGV</strong>. Here you can see original bigWig datasets along with predicted peaks.</small></p>\n<h2 id=\"what-sequence-motifs-are-found-within-peaks\"><a href=\"#what-sequence-motifs-are-found-within-peaks\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>What sequence motifs are found within peaks</h2>\n<p>In this experiment antibodies against Reb1 protein have been used for immunoprecipitaion. The recognition site for Reb1 is <code>TTACCCG</code> (<a href=\"http://www.sciencedirect.com/science/article/pii/S1097276508008423\" target=\"_blank\" rel=\"noopener noreferrer\">Badis:2008</a> and <a href=\"http://www.nature.com/nature/journal/v431/n7004/abs/nature02800.html\" target=\"_blank\" rel=\"noopener noreferrer\">Harbison:2004</a>). To find out which sequence motifs are found within our peaks we first need to convert coordinates into underlying sequences. This is done using <strong>Fetch Alignments/Sequences → Extract Genomic DNA</strong> tool:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/extract_dna.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Extracting genomic DNA</strong> corresponding to ChIP-seq peaks. Here we use <code>Merged peaks</code> dataset generated few steps earlier.</small></td>\n</tr>\n</tbody>\n</table>\n<p>Next, we need to make sure that all sequences are sufficiently long for finding patterns. <a href=\"http://meme-suite.org/\" target=\"_blank\" rel=\"noopener noreferrer\">MEME</a>, the tools we will use to find motifs, required sequences to be at least 8 nucleotides long. So we will remove short sequences using <strong>FASTA manipulation → Filter sequences by length</strong> tool:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/fa_length.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Filtering FASTA</strong> by length. Here we are removing all sequences shorted than 8 nucleotides.</small></td>\n</tr>\n</tbody>\n</table>\n<p>Now we can run <strong>Motif Tools → MEME</strong>:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/meme1.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Running MEME</strong> on length-filtered FASTA sequences from the previous step. Note that <strong>Options configuration</strong> is set to <code>Advanced</code> and <strong>Check reverse complement</strong> is set to <code>Yes</code>.</small></td>\n</tr>\n</tbody>\n</table>\n<p><code>MEME</code> generates a number of outputs. The most interesting is HTML Report. It shows that 620 regions contain <code>TTACCCG</code> motif:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/meme2.png\"></td>\n</tr>\n<tr>\n<td><small><strong>MEME Motif</strong> found in 620 sequences corresponding to common peak regions.</small></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"summarizing-chip-signal-enrichment-across-all-genes\"><a href=\"#summarizing-chip-signal-enrichment-across-all-genes\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Summarizing ChIP signal enrichment across all genes</h2>\n<p>How many genes contain upstream regions enriched in ChIP tags. This is often represented as a heatmap:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/plotHeatmap_example.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Heatmap example</strong> from <a href=\"https://deeptools.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener noreferrer\">DeepTools documentation</a>.</small></td>\n</tr>\n</tbody>\n</table>\n<p>To generate the heatmap we must first produce normalized datasets for the two replicated we have. This is done using <strong>NGS: DeepTools → bamCompare</strong> tool:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/bamCompare1.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Running <code>bamCompare</code></strong> on replicate 1. Here we set <strong>Method to use for scaling the largest sample to the smallest</strong> to <code>SES</code> (although you may want to try other methods as well. SES was briefly discussed <a href=\"/tutorials/chip/#assessing-signal-strength\">above</a>.</small></td>\n</tr>\n</tbody>\n</table>\n<div class=\"alert alert-warning trim-p\">\n<p>Perform the same analysis on Replicate 2 datasets and rename the two resulting items as <code>R1 normalized</code> and <code>R2 normalized</code>.</p>\n</div>\n<p>Because we want to plot enrichment around genes we need to download gene annotation. We will use <strong>Get Data → UCSC Main</strong> for this:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/ucsc1.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Getting data from UCSC</strong>. Here make sure you select <strong>assembly</strong> called <code>sacCer3</code> and you are choosing <code>SGD Genes</code>. Clicking <strong>get output</strong> will show the next screen shown below.</small></td>\n</tr>\n<tr>\n<td><img src=\"/src/tutorials/chip/ucsc2.png\"></td>\n</tr>\n<tr>\n<td><small>Here just click <strong>Send query to Galaxy</strong>.</small></td>\n</tr>\n</tbody>\n</table>\n<p>Next, to prepare data necessary for drawing the heatmap we will use <strong>NGS: DeepTools → computeMatrix</strong> utility:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/computeMatrix1.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Computing matrix</strong> - the data from which heatmap will be built. Here <strong>both</strong> normalized datasets are select within <strong>Score file</strong> box, yeast genes we have just downloaded from UCSC are chosen as <strong>Regions to plot</strong>. 'reference-point is set as <strong>computeMatrix main option</strong> and, finally, upstream and downstream distances are set to 2,000 bp. Obviously you are welcome to play with these parameters. </small></td>\n</tr>\n</tbody>\n</table>\n<p>Finally, we can visualize the heatmap by using <strong>NGS: DeepTools → plotHeatmap</strong> tool:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/plotHeatmap.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Drawing heatmap</strong> with <code>plotHeatmap</code> tool. </small></td>\n</tr>\n</tbody>\n</table>\n<p>The resulting image shows that a significant fraction of 6,692 genes present in the annotation data we have used contain Reb1 binding sites within their upstream regions:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"/src/tutorials/chip/heatmap.png\"></td>\n</tr>\n<tr>\n<td><small><strong>Heatmap</strong> showing distribution of Reb1 binding sites across upstream regions of 6,692 yeast genes.</small></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"we-did-not-fake-this\"><a href=\"#we-did-not-fake-this\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>We did not fake this</h1>\n<p>This entire analysis is available as a Galaxy history <a href=\"https://usegalaxy.org/u/aun1/h/reb1-yeast-tutorial\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>. Import it and play with it.</p>\n<h1 id=\"and-so-it-goes\"><a href=\"#and-so-it-goes\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>And so it goes...</h1>\n<p>Hopefully this tutorial has given you the taste for what is possible. There are more tools out there so experiment! If things do not work - complain using <code>Open Chat</code> button below or our <a href=\"https://help.galaxyproject.org/\" target=\"_blank\" rel=\"noopener noreferrer\">support forum</a>.</p>\n"}},"context":{}}