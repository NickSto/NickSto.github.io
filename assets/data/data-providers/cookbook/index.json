{"hash":"6a87f55bb3e5a997903b2c87cff72c00cc3c86c4","data":{"article":{"id":"56cf40ee9c2266b9c181ba7e852efb93","title":"DataProviders Cookbook","tease":"","image":"","images":{},"category":null,"contact":"","date":null,"content":"<div class='left'></div>\n<p>This is a collection of examples outlining both using and creating <a href=\"/data-providers/\">DataProviders</a>.</p>\n<h2 id=\"using-existing-providers\"><a href=\"#using-existing-providers\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Using existing providers</h2>\n<hr>\n<h4 id=\"i-want-to-paginate-my-incoming-data\"><a href=\"#i-want-to-paginate-my-incoming-data\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>I want to paginate my incoming data</h4>\n<p>You want to look at sets (or pages) of data points from your dataset 1000 at a time and have an easy way\nto move between those sets.</p>\n<p>This can be accomplished with most text based datatypes using the <code>limit</code> and <code>offset</code> options:</p>\n<pre><code class=\"language-python\">def paginate_column_data( dataset, page_size, curr_page, **more_options )\n    limit = page_size\n    offset = curr_page * page_size\n    return list( dataset1.datatype.dataprovider( dataset1, 'column',\n        limit=limit, offset=offset, **more_options ) )\n\npage1 = paginate_column_data( dataset1, 1000, 0 )\npage2 = paginate_column_data( dataset1, 1000, 1 )\n# ...\n</code></pre>\n<p>Note: since data providers return generators, make sure to use <code>list</code> in order to 'compile' the lines into a list\nif that's what you need.</p>\n<p>Notes on limit and offset:</p>\n<ul>\n<li>Filtered data (such as blank lines, comment lines, or non regex matching lines) do not apply to the limit or offset -\nonly the final, valid data.</li>\n<li>Negative or zero limits (or if the dataset has no data) will return an empty list/generator</li>\n<li>Limits above the number of lines/data in your dataset will return only the amount available (it will not error\nor be padded with None values, etc.). In the above example, the last 'page' may not have 1000 lines but you don't\nhave to worry about that - it will send only the remainder without any calculations needed.</li>\n<li>Negative offsets will be treated as offset = 0 (the beginning)</li>\n<li>Offsets past the total number of lines/data in your dataset will return an empty list/generator (no errors)</li>\n</ul>\n<hr>\n<h4 id=\"i-want-to-filter-my-data\"><a href=\"#i-want-to-filter-my-data\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>I want to filter my data</h4>\n<p>You want to only use data that contains the string 'exon' in the third column of your dataset data.</p>\n<p>This can be accomplished using the <code>regex_list</code> option:</p>\n<pre><code class=\"language-python\">exons = list( hda.datatype.dataprovider( hda, 'column', regex_list=[ '\\S+\\s+\\S+\\s+exon' ] ) )\n</code></pre>\n<p>If 'exon' could appear in either the third or fourth column you could add another regex expression:</p>\n<pre><code class=\"language-python\">exons = list( hda.datatype.dataprovider( hda, 'column', regex_list=[ '\\S+\\s+\\S+\\s+exon', '\\S+\\s+\\S+\\s+\\S+\\s+exon' ] ) )\n</code></pre>\n<p>To filter these <em>out</em>, set the <code>invert</code> option to True:</p>\n<pre><code class=\"language-python\">regex_list = [ '\\S+\\s+\\S+\\s+exon', '\\S+\\s+\\S+\\s+\\S+\\s+exon' ]\nnon_exons = list( hda.datatype.dataprovider( hda, 'column', regex_list=regex_list, invert=True ) )\n</code></pre>\n<p>Notes on <code>regex_list</code>:</p>\n<ul>\n<li>Expressions are compared against full lines of data. Whitespace at the beginning and end of the line is stripped\nbeforehand and no comparisons are made against blank lines or comment lines (unless included explicitly).</li>\n<li>When sending regex expressions over the API your client may URL encode the expression - be careful to use proper\nescaping (e.g. '\\b' must be '\\b').</li>\n<li>A line of data is considered matching if <em>any</em> of the expressions match (as opposed to all).</li>\n<li>Under the hood, re.match is used for the filtering. It may be useful to try your expressions in a REPL if you have\nproblems.</li>\n</ul>\n<hr>\n<h4 id=\"no-i-want-to-filter-my-data-using-a-calculation---not-regex\"><a href=\"#no-i-want-to-filter-my-data-using-a-calculation---not-regex\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>No, I want to filter my data using a calculation - not regex</h4>\n<p>You can pass column-based filters into any dataprovider that is derived from <code>ColumnDataProvider</code> including\n'dataset-column', 'dict', 'genomic-region', and 'interval'. <code>filters</code> is passed into python as a list of strings. Each\nstring is a 3-tuple of <code>( column_index, operator, value )</code> separated by hyphens. For example, to filter returned lines\nto only those that are greater than or equal to 20000 in the 2nd column:</p>\n<pre><code class=\"language-python\">data = list( hda.datatype.dataprovider( hda, 'column', filters=[ '1-ge-20000' ] ) )\n</code></pre>\n<p>Filters are AND'ed together.</p>\n<p>These types of filters can be passed to the API as well by sending as a comma-separated-list:</p>\n<pre><code class=\"language-javascript\">    jQuery.ajax( '/api/datasets/' + id, {\n        data : {\n            data_type   : 'raw_data',\n            provider    : 'dataset-column',\n            limit       : 200,\n            offset      : 200 * currPage,\n            // get anything in chr1 between 20000 and 50000\n            filters     : [ '0-eq-chr1', '1-ge-20000', '2-lt-50000' ].join( ',' )\n        }\n    })\n</code></pre>\n<p>The operators available depend on the column type:</p>\n<ul>\n<li>\n<p>numeric:</p>\n<ul>\n<li>'lt': is less than 'value'</li>\n<li>'le': is less than or equal to 'value'</li>\n<li>'eq': is equal to 'value'</li>\n<li>'ne': is not equal to 'value'</li>\n<li>'ge': is greater than or equal to 'value'</li>\n<li>'gt': is greater than 'value'</li>\n</ul>\n</li>\n<li>\n<p>string:</p>\n<ul>\n<li>'eq': column exactly equals 'value'</li>\n<li>'has': contains the substring 'value'</li>\n<li>'re': matches the regular expression 'value'</li>\n</ul>\n</li>\n</ul>\n<p>You may also want to create your own filter function. Pass a function into any <code>LineDataProvider</code>-derived provider\nunder the <code>filter_fn</code> keyword argument:</p>\n<pre><code class=\"language-python\">def filter_start_lt_10k( line ):\n    try:\n        start_pos = int( line.split( '\\t' )[1] )\n        if start_pos >= 10000:\n            return line\n    except:\n        pass\n    return None\ndata = list( hda.datatype.dataprovider( hda, 'column', filter_fn=filter_start_lt_10k ) )\n</code></pre>\n<p>Notes:</p>\n<ul>\n<li>This only works in python and is not available over the API</li>\n<li>The <code>filter_fn</code> is passed the unparsed line (rather than columns or parsed columns). You won't receive blank lines\nor comment lines, however (unless another option changes that), and whitespace is removed from the front and end\nof the line.</li>\n<li>Return <code>None</code> from the <code>filter_fn</code> to effectively filter out a line.</li>\n<li>You can also return a modified version of the line (partial data, re-formatting, etc.).</li>\n<li>Data filtered in the above way works with limit and offset.</li>\n</ul>\n<p>Alternately, you can of course filter directly <em>after</em> the provider yields the data:</p>\n<pre><code class=\"language-python\">def generate_lt( dataset, pos, **options ):\n    for col_list in hda.datatype.dataprovider( hda, 'column', **options ):\n        if col_list[1] >= pos:\n            yield col_list\n</code></pre>\n<p>Note that this pattern does not play well with limit and offset.</p>\n<hr>\n<h4 id=\"i-want-to-sort-my-data-using-a-dataprovider\"><a href=\"#i-want-to-sort-my-data-using-a-dataprovider\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>I want to sort my data using a DataProvider</h4>\n<p>Unfortunately, this is currently un-implemented. You can still however use the installed sort tool to sort the data\ninto a new dataset before-hand or sort after the data have been provided in your client, script, or template.</p>\n<hr>\n<h4 id=\"my-data-has-comment-lines-that-dont-start-with-\"><a href=\"#my-data-has-comment-lines-that-dont-start-with-\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>My data has comment lines that don't start with '#'</h4>\n<p>Many of the default behaviors of (text-based) DataProviders are configurable:</p>\n<ul>\n<li>to change which lines are considered comments and filtered out, set <code>comment_char</code>; to not filter out <em>any</em> lines\nas comments set this to <code>None</code>.</li>\n<li>to include blank lines in your data, set <code>provide_blank</code> to <code>True</code>.</li>\n<li>to include the original whitespace (including newline characters) that may occur at the beginning and end of your\nlines of data, set <code>strip_lines</code> to <code>False</code>.</li>\n<li>to include the original whitespace but remove the newline characters, set <code>strip_lines</code> to <code>False</code> <em>and</em>\n<code>strip_newlines</code> to <code>True</code>.</li>\n</ul>\n<hr>\n<h4 id=\"i-want-to-use-some-data-in-a-visualization-template-using-python\"><a href=\"#i-want-to-use-some-data-in-a-visualization-template-using-python\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>I want to use some data in a visualization template using python</h4>\n<p>Most of the examples that use python both here and in <a href=\"/data-providers/\">DataProviders</a> should be good starting points for\nvisualizations in python.</p>\n<hr>\n<h4 id=\"i-want-to-use-some-data-in-a-visualization-template-using-javascript\"><a href=\"#i-want-to-use-some-data-in-a-visualization-template-using-javascript\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>I want to use some data in a visualization template using !JavaScript</h4>\n<p>You want to get the data into javascript for use with a graphing library or some other javascript technology. There\nare two points in the visualizations execution where you might want to do this:</p>\n<ol>\n<li>'Bootstrapping': rendering the data as JSON using the Mako + the server <em>before</em> it's sent to the browser</li>\n<li>Via AJAX and the API: getting data (or more data) when the user interacts with your page after it's been sent</li>\n</ol>\n<p>You can bootstrap JSON data by using a combination of python and javascript:</p>\n<pre><code class=\"language-mako\">&#x3C;script type=\"text/javascript\">\n&#x3C;%\n    # first 3000 only - we'll load the rest later\n    data = list( hda.datatype.dataprovider( hda, 'interval-dict', limit=3000 ) )\n%>\nvar bootstrappedFirstPage = ${h.to_json_string( data, indent=2 )};\n// draw this page...\n&#x3C;/script>\n</code></pre>\n<p>This works because the stringified JSON will be printed as a JavaScript object literal. If you use this, you can open\nyour visualization's page in the browser using 'show page source' - the data will be printed there in JSON form.</p>\n<p>You can also access data providers through the datasets API using an AJAX call within your page (here, we'll use\njQuery's ajax framework - you can use whatever your comfortable with):</p>\n<pre><code class=\"language-javascript\">&#x3C;script type=\"text/javascript\">\n    // ...\n    $button.click( function( ev ){\n        var button_page = $button.data( 'page' );\n        var xhr = jQuery.getJSON( \"/api/datasets/\" + encodedHdaId, {\n            // we need to send both the raw_data data_type and the provider name\n            data_type : 'raw_data',\n            provider  : 'interval-dict',\n            limit     : 3000,\n            offset    : ( button_page * 3000 )\n        });\n        xhr.done( function( response ){\n            // draw the next page...\n        });\n    })\n&#x3C;/script>\n</code></pre>\n<hr>\n<h2 id=\"defining-new-providers\"><a href=\"#defining-new-providers\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Defining new providers</h2>\n<p>If you have a new datatype to add to Galaxy or you need functionality that none of the existing providers can give,\nyou may want to define a new <a href=\"/data-providers/\">DataProvider</a>.</p>\n<p>There are several ways to define new providers:</p>\n<ul>\n<li>Create a method that uses existing provider classes, modifying their options or output in the method.</li>\n<li>Compose a new provider from several other existing providers.</li>\n<li>Create a new provider class.</li>\n</ul>\n<hr>\n<h4 id=\"i-want-an-easy-way-to-define-a-provider-for-a-new-format\"><a href=\"#i-want-an-easy-way-to-define-a-provider-for-a-new-format\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>I want an easy way to define a provider for a new format</h4>\n<p>You have a new format with key/value pairs that:</p>\n<ul>\n<li>uses equal signs surrounded by spaces for separation</li>\n<li>considers lines starting with a semicolon to be comments</li>\n<li>each value in the key/value pair is a number or blank</li>\n<li>and whitepace is important and should be kept in</li>\n</ul>\n<pre><code>; Some crazy format developed in the 80's for use with dot-matrix printers\nsamples taken = 24\nsamples processed = 23\ninterns left =\n    missed the grant by = 1\nmoney recvd = 0.00\n</code></pre>\n<p>You can override the settings/options for existing providers, wrap it in a function, and return the provider:</p>\n<pre><code class=\"language-python\">from galaxy.datatypes.dataproviders import column\ndef provide_key_value( dataset, **settings ):\n    settings[ 'deliminator' ] = ' = '\n    settings[ 'comment_char' ] = ';'\n    settings[ 'column_types' ] = [ 'str', 'float' ]\n    settings[ 'strip_lines' ] = False\n    settings[ 'strip_newlines' ] = True\n    return column.ColumnarDataProvider( dataset, **settings )\n\nfor pair in provide_columns_for_my_format( hda ):\n    print pair\n\n# ['samples taken', 24.0]\n# ['samples processed', 23.0]\n# ['interns left', None]\n# [' missed the grant by', 1.0]\n# ['money recvd', 0.0]\n</code></pre>\n<hr>\n<h4 id=\"i-want-to-add-my-provider-to-a-datatype\"><a href=\"#i-want-to-add-my-provider-to-a-datatype\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>I want to add my provider to a datatype</h4>\n<p>You now want to add <code>provide_columns_for_my_format</code> to your new datatype <code>MyFormat</code>. In it's datatype class definition\nyou'd need two things:</p>\n<ol>\n<li>Decorate your <code>MyFormat</code> datatype class with <code>@dataproviders.decorators.has_dataproviders</code>. This sets up a class\nto use dataproviders.</li>\n<li>Add your method to the datatype class and decorate that method with <code>@dataproviders.decorators.dataprovider_factory</code>\nsending a name for the format provided and a <code>settings</code> map of options for the method/provider you want available\nthrough the API (for more information on this variable see 'I want the options my provider uses available over the\nAPI').</li>\n</ol>\n<pre><code class=\"language-python\">from galaxy.datatypes.dataproviders import decorators\nfrom galaxy.datatypes.dataproviders import column\n\n@decorators.has_dataproviders\nclass MyFormat( data.Text ):\n    # ...\n\n    @decorators.dataprovider_factory( 'key-value', column.ColumnarDataProvider.settings )\n    def provide_columns_for_my_format( hda, **settings ):\n        # ...\n\n# then - elsewhere...\nfor pair in myformatted_dataset.datatype.dataprovider( myformatted_dataset, 'key-value', limit=1 ):\n    print pair\n\n# ['samples taken', 24.0]\n</code></pre>\n<p>This pattern is used often for more semantic providers (<code>IntervalDataProvider</code>, <code>GenomicRegionDataProvider</code>) to pluck\nstart, end, and chrom values from various datatypes even though they may appear in different columns.</p>\n<hr>\n<h4 id=\"none-of-the-existing-providers-do-what-i-want---but-id-still-like-to-keep-it-simple\"><a href=\"#none-of-the-existing-providers-do-what-i-want---but-id-still-like-to-keep-it-simple\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>None of the existing providers do what I want - but I'd still like to keep it simple</h4>\n<p>Another way of creating a new provider from existing providers is to compose one from the others.</p>\n<p>In the following pattern which is seen throughout this cookbook, we use a dataset as a <em><code>data_source</code></em>:</p>\n<pre><code class=\"language-python\">for datum in dataset.datatype.dataprovider( dataset, 'my-provider' ):\n    print datum\n</code></pre>\n<p>The <code>data_source</code> for data providers can be any python iterator, including any other <a href=\"/data-providers/\">DataProvider</a>:</p>\n<pre><code class=\"language-python\">dataprovider1 = MyFirstDataProvider( dataset, setting1=... )\ndataprovider2 = MySecondDataProvider( dataprovider1, setting2=... )\nfor datum in dataprovider2:\n    print datum\n</code></pre>\n<p>When a fully formatted, filtered, and parsed datum is yielded from <code>dataprovider1</code> it then will be passed to\n<code>dataprovider2</code> where it can be further formatted, filtered, or parsed.</p>\n<hr>\n<h4 id=\"i-want-to-define-a-new-dataprovider-class\"><a href=\"#i-want-to-define-a-new-dataprovider-class\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>I want to define a new DataProvider class</h4>\n<p>This is the most powerful but complex ways to create a new data provider.</p>\n<p>All <a href=\"/data-providers/\">DataProvider</a> classes should inherit at least from <code>datatypes.dataproviders.base.DataProvider</code>. If\nyou'll be working with a data format where each datum is contained on a line, you may want to start with either the\nFilteredLineDataProvider or the RegexLineDataProvider. If it takes more than one line to create a single datum (e.g.\nMAF format), you may want to start with the BlockDataProvider.</p>\n<hr>\n<h4 id=\"i-want-the-options-my-provider-uses-available-over-the-api\"><a href=\"#i-want-the-options-my-provider-uses-available-over-the-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>I want the options my provider uses available over the API</h4>\n<p>Settings:</p>\n<p>In order for your providers options to be available and parsed properly from a query string (from an API call),\nyou'll need a class level dictionary named <code>settings</code> containing the keyword arguments that should be parsed and sent to\nyour provider's <code>__init__</code> method. For example, the <code>FilteredLineDataProvider</code> has the following <code>settings</code> variable:</p>\n<pre><code class=\"language-python\">    settings = {\n        'strip_lines'   : 'bool',\n        'strip_newlines': 'bool',\n        'provide_blank' : 'bool',\n        'comment_char'  : 'str',\n    }\n    def __init__( self, source, strip_lines=True, strip_newlines=False, provide_blank=False,\n                  comment_char=DEFAULT_COMMENT_CHAR, **kwargs ):\n        # ...\n</code></pre>\n"}},"context":{}}