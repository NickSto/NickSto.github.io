{"hash":"c32ecfdb33b075b0057598b5b9118f3554a398cf","data":{"article":{"id":"3735421c69fad1b4dbc2c5a899ea5916","title":"Data Sources and Tests: What types of data can be visualized","tease":"","image":"","images":{},"category":null,"contact":"","date":null,"content":"<h2 id=\"data-sources-and-tests-what-types-of-data-can-be-visualized\"><a href=\"#data-sources-and-tests-what-types-of-data-can-be-visualized\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Sources and Tests: What types of data can be visualized</h2>\n<p>There can be multiple possible sources/target objects defined for each visualization, For example, a visualization may\nbe applicable to both SAM and BAM files and have a <code>data_source</code> defined for each:\n<code>xml &#x3C;data_sources> &#x3C;data_source> &#x3C;model_class>HistoryDatasetAssociation&#x3C;/model_class> &#x3C;test type=\"isinstance\" test_attr=\"datatype\" result_type=\"datatype\">tabular.Sam&#x3C;/test> &#x3C;/data_source> &#x3C;data_source> &#x3C;model_class>HistoryDatasetAssociation&#x3C;/model_class> &#x3C;test type=\"isinstance\" test_attr=\"datatype\" result_type=\"datatype\">binary.Bam&#x3C;/test> &#x3C;/data_source> &#x3C;/data_sources> ...</code></p>\n<p>When the registry is deciding whether to render a link:</p>\n<ul>\n<li>Each <code>data_source</code> is checked in turn.</li>\n<li>If the source of data passes any of the tests in a <code>data_source</code> a link is rendered.</li>\n<li>If the <code>data_source</code> tests fail, the next <code>data_source</code> is checked and the process is repeated until there are no\nmore <code>data_sources</code>.</li>\n</ul>\n<p>In the example above, if the registry was checking a BAM file, the first <code>data_source</code>'s tests would fail, the registry\nwould check the next <code>data_source</code>, those tests would pass, and a link would be rendered.</p>\n<p>This control flow described above implicitly means that it's better to order <code>data_sources</code> from more specific first to\nmore general after. This allows us to send different or added settings based on the 'cascading' effect of the flow.</p>\n<h4 id=\"model_class\"><a href=\"#model_class\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>model_class</h4>\n<p>Inside each <code>data_source</code>, the first test uses the <code>data_source</code> sub-element <code>model_class</code>. If the target object is\nthe same python class as the class listed here, then the remaining <code>data_source</code> tests are then run.\n<code>xml &#x3C;data_source> &#x3C;model_class>HistoryDatasetAssociation&#x3C;/model_class> ... &#x3C;/data_source></code></p>\n<p><strong><code>model_class</code> is the only required test for all <code>data_sources</code> and must be defined</strong>.</p>\n<p>In the majority of cases, your visualization will be using data from a dataset in a user's history - so\n<code>HistoryDatasetAssociation</code> will be the proper setting.</p>\n<h4 id=\"test\"><a href=\"#test\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>test</h4>\n<p><code>test</code> elements define tests to see if a visualization can be applied using the model as a source of data. <strong>If\nany single test passes, the visualization is considered applicable</strong> and a link will be rendered (in other words, the\ntests are effectively OR'ed). There can be zero or more data_source tests (sometimes just checking the model_class alone\nis enough information).</p>\n<p>(Note: the <code>model_class</code> is an exception to tests being OR'd: it is effectively AND'd to the whole set of tests.)</p>\n<p>Test <code>type</code>s are currently limited to:</p>\n<p>1) <strong>isinstance</strong>: testing a LibraryDatasetDatasetAssociation or HistoryDatasetAssociation's <code>.datatype</code> attribute\nfor class inheritance:\n<code>xml &#x3C;test type=\"isinstance\" test_attr=\"datatype\" result_type=\"datatype\">data.Newick&#x3C;/test></code></p>\n<p>2) <strong>has_dataprovider</strong>: testing if the attribute of a data_source/model has a specific\n<a href=\"/src/data-providers/index.md\">DataProvider</a>:\n<code>xml &#x3C;test type=\"has_dataprovider\" test_attr=\"datatype\">node-edge&#x3C;/test></code></p>\n<p>or 3) <strong>eq</strong>: using string comparison of any model's attribute (the default - no <code>type</code>s are required):\n<code>xml &#x3C;test test_attr=\"dbkey\">hg18&#x3C;/test></code></p>\n<p>Note that, for <code>datatype</code> testing:</p>\n<ul>\n<li>you need to use the datatype module namespace (e.g. <code>data.Newick</code> or <code>tabular.Tabular</code>)</li>\n<li>the use of isinstance allows you some flexibility for your testing, as any sub-class of a datatype will still pass\nthe <code>datatype</code> test (e.g. a SAM file will be considered applicable if you test for the <code>datatype</code> <code>tabular.Tabular</code>)</li>\n<li>datatypes are checked against the datatype registry of your Galaxy installation</li>\n</ul>\n<hr>\n<h2 id=\"data-sources-and-to_params-how-to-define-outgoing-links-to-your-visualization\"><a href=\"#data-sources-and-to_params-how-to-define-outgoing-links-to-your-visualization\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Data Sources and to_params: How to define outgoing links to your visualization</h2>\n<p>Each <code>data_source</code> can define zero or more <code>to_param</code> elements. Each <code>to_param</code> will add one key/value pair\nto the query string of the URL of your link <strong>allowing control over what information is contained in your visualization\nlink and controlling what is passed to your visualization code</strong>. For example:\n<code>xml &#x3C;data_source> &#x3C;model_class>HistoryDatasetAssociation&#x3C;/model_class> &#x3C;test type=\"isinstance\" test_attr=\"datatype\" result_type=\"datatype\">tabular.Sam&#x3C;/test> &#x3C;to_param param_attr=\"id\">dataset_id&#x3C;/to_param> &#x3C;/data_source> ...</code></p>\n<p>In this case, the to_param will take the attribute of the target object 'id' (<code>param_attr=\"id\"</code>) and attach a key\nvalue pair on the generated link query string of: <code>?dataset_id=&#x3C;the HDAs id></code>.</p>\n<p>Note: ids are automatically encoded when the link is generated.</p>\n<p>The final link generated points to the exposed render method of the visualization.py controller:\n<code>html &#x3C;a href=\"http://localhost:8080/visualization/show/myvis?dataset_id=f7bb1edd6b95db62\">My Visualization&#x3C;/a></code></p>\n<p>The visualization name is passed as the first argument and appears after the <code>show</code> 'verb'.</p>\n<p>Other values can be passed in as well depending on the data source either using the target's attributes or direct\nassignment:\n<code>xml &#x3C;data_source> &#x3C;model_class>LibraryDatasetDatasetAssociation&#x3C;/model_class> &#x3C;test type=\"isinstance\" test_attr=\"datatype\" result_type=\"datatype\">data.Data&#x3C;/test> &#x3C;to_param param_attr=\"id\">dataset_id&#x3C;/to_param> &#x3C;to_param assign=\"ldda\">hda_ldda&#x3C;/to_param> &#x3C;/data_source></code></p>\n<pre><code class=\"language-#!\">&#x3C;a href=\"http://localhost:8080/visualization/show/myvis?dataset_id=f7bb1edd6b95db62&#x26;hda_ldda=ldda\">My Visualization&#x3C;/a>\n</code></pre>\n<hr>\n<h2 id=\"params-how-to-parse-an-incoming-link-for-your-template\"><a href=\"#params-how-to-parse-an-incoming-link-for-your-template\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Params: How to parse an incoming link for your template</h2>\n<p>When the link generated from the <code>data_source</code> is used, <strong>resources listed in <code>params</code> are parsed from the query string\nand sent to the template</strong>. 'Resources' can be considered any data that needs to be parsed or converted from a string\nbefore being sent to the visualization template (primitives such as <code>int</code>s or <code>bool</code>eans, more complex data such as\nmodels, or lists of either).</p>\n<p>The registry uses the <code>ResourceParser</code> class located in <code>lib/galaxy/visualization/plugins/resource_parser.py</code> to do this.</p>\n<p>For example, the scatterplot visualization has the following params (it only needs one 'resource' - the HDA target):\n`<code></code>xml</p>\n<pre><code>  &#x3C;param type=\"dataset\" var_name_in_template=\"hda\" required=\"true\">dataset_id&#x3C;/param>\n</code></pre>\n<pre><code>* The text node of the element is the key of the key/value pair in the query string: `dataset_id`\n* The `required=\"true\"` attribute tells the registry to throw an error immediately if the `dataset_id` key is not in\n  the query string of the incoming link\n* The type tells the registry to convert that value into a dataset (implicitly the dataset type receives an id)\n* The registry will attempt to get the full model of the dataset (SQLAlchemy `eagerloading` is on)\n* The `var_name_in_template` tells the registry to pass the dataset model to the template using the context variable\n  name `hda`\n\nOther complex `params` are also parsed:\n* `type=\"hda_or_ldda\"`: for visualizations that accept either an HDA or LDDA\n* `type=\"dbkey\"`: for visualizations that require the genome build of a target object\n* `type=\"json\"`: when data is bundled and passed as JSON (the string will be parsed into a python structure for the\n  template)\n\nPrimitive types are parsed as well: 'str', 'bool', 'int', 'float' ('str' is the default type).\n\nBesides the `param` attributes above, the following are also available:\n* csv : `csv=\"true\"` will split the query string value at commas, and recursively parse each element using the `type`\n  attribute sending the final list to the template. For example: `&#x3C;param type=\"int\" csv=\"true\">indeces&#x3C;/param>` would\n  parse the query string key/value pair `?indeces=3,4,9,12&#x26;` and send it to the template as: `indeces = [ 3, 4, 9, 12 ]`\n* default : you can provide a default value for a param and, if it's missing from the query string, that value will\n  be parsed using `type` and sent to the template\n\nAny parameters defined in the `params` section of your config file are available here. In addition, other variables\nare available (see [VisualizationsRegistry/Code](/src/visualizations-registry/code/index.md) for more info).\n\n\n## Other configuration options\n\nYou can also optionally specify a `render_location` element. This becomes the `target` attribute of the link generated\nfor your visualizations. If you want the visualization to load in a new window, set this to `_blank`, in the top frame\n(and therefore remove the two side panels) use `_top`, or if you're fine loading it in the center panel with both\nside panels in place use `galaxy_main` (this is the default `render_location`).\n\n\n## Troubleshooting\n\nYou can **test the validity of your XML registry file** by using the DTD defined in `visualizations_conf.xml` itself.\nOn the command line:\n```bash\nxmllint --valid --noout myvis.xml\n</code></pre>\n<p>If <strong>there's an error parsing the configuration</strong> of a visualization, you'll find an error similar to this in the\nserver logs:\n<code>#! galaxy.web.base.pluginframework WARNING 2014-01-28 10:26:04,147 VisualizationsRegistry, plugin load failed or disabled: ./config/plugins/visualizations/sweepster. Skipping...</code></p>\n<p>If a configuration loads successfully and you're <strong>not seeing a link</strong> to it on a dataset or data source that\n<em>should</em> display one:</p>\n<ul>\n<li>Check the configurations <code>model_class</code> - it is case sensitive and the class should be part of <code>model/__init__.py</code></li>\n<li>Check the order of your <code>data_sources</code> - order matters here - go from specific first to general</li>\n<li>Check your tests - attributes must be valid attributes of the <code>model_class</code></li>\n</ul>\n<p>If <strong>your link isn't turning out properly</strong>, check your <code>param</code> definitions. Again, they need to be valid attributes\nof the <code>model_class</code>.</p>\n"}},"context":{}}